<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pramod ‚Äì 10 Smart City Business Cases</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;800&display=swap" rel="stylesheet">
    
    <style>
        /* --- General Styling & Variables (Unchanged) --- */
        :root {
            --bg-dark: #0c0f1a;
            --glass: rgba(255, 255, 255, 0.16);
            --accent: #00eaff;
            --accent2: #9c59ff;
            --text-light: #e8e8e8;
            --radius: 18px;
            --blur: 18px;
            --code-bg: rgba(0, 0, 0, 0.3);
            --link-hover: #1c2747;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: "Poppins", sans-serif; }
        html { scroll-behavior: smooth; } /* Smooth scrolling to anchors */
        body {
            background: radial-gradient(circle at top, #1b2238, #090b14 70%);
            color: var(--text-light);
            min-height: 100vh;
            padding: 40px 20px;
        }
        .container {
            max-width: 1200px;
            width: 100%;
            margin: 0 auto;
        }
        
        /* --- Card & Header Styling --- */
        header.card, .content-section {
            background: var(--glass);
            backdrop-filter: blur(var(--blur));
            border-radius: var(--radius);
            padding: 40px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.35);
            margin-bottom: 30px;
        }
        .badge {
            display: inline-block;
            padding: 6px 14px;
            border-radius: 999px;
            background: rgba(0, 234, 255, 0.1);
            color: var(--accent);
            font-size: 0.8rem;
            margin-bottom: 12px;
        }
        h1 {
            font-size: 2.8rem;
            margin-bottom: 6px;
            background: linear-gradient(90deg, #fff, var(--accent));
            -webkit-background-clip: text;
            color: transparent;
        }
        
        /* --- Navigation Menu Styling --- */
        .navigation {
            background: rgba(255, 255, 255, 0.05);
            border-radius: var(--radius);
            padding: 20px;
            margin-bottom: 30px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
        }
        .navigation h2 {
            font-size: 1.6rem;
            color: var(--accent);
            margin-bottom: 15px;
        }
        .problem-list {
            list-style: none;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
        }
        .problem-list li a {
            display: block;
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            color: var(--text-light);
            text-decoration: none;
            font-weight: 600;
            transition: background 0.3s, color 0.3s;
            border-left: 5px solid var(--accent2);
        }
        .problem-list li a:hover {
            background: var(--link-hover);
            color: var(--accent);
        }

        /* --- Content Section Styling --- */
        .content-section {
            padding: 30px 40px;
        }
        .content-section:target {
            /* Highlight the section when navigated via anchor link */
            border: 1px solid var(--accent);
            box-shadow: 0 0 30px var(--accent), 0 0 5px rgba(255, 255, 255, 0.2);
        }

        h2.problem-title { 
            margin-top: 0;
            margin-bottom: 15px; 
            font-size: 2rem;
            color: var(--accent);
            padding-bottom: 5px;
            border-bottom: 2px solid rgba(0, 234, 255, 0.3);
        }
        h3 { margin-top: 20px; margin-bottom: 6px; font-size: 1.4rem; color: var(--accent2); }
        p { margin-bottom: 8px; opacity: 0.9; line-height: 1.6; }
        ul { margin-left: 18px; margin-top: 6px; margin-bottom: 12px; }
        li { margin-bottom: 4px; }
        
        /* --- Code Block Styling --- */
        pre {
            background: var(--code-bg);
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            margin-top: 10px;
            margin-bottom: 15px;
            font-size: 0.9rem;
        }
        code {
            font-family: 'Consolas', 'Monaco', monospace;
            color: var(--text-light);
        }
        .back-to-top {
            display: inline-block;
            margin-top: 20px;
            color: var(--accent);
            text-decoration: none;
            font-weight: 600;
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <div class="container">
        
        <header class="card">
            <span class="badge">Next‚ÄëGen City Design ¬∑ DAA Project</span>
            <h1>Pramod S Indi</h1>
            <p><b>Module:</b> Smart Traffic Optimization System</p>
            <p>This page details the **10 business cases** identified for smart city development based on the Pramod City map.</p>
        </header>
        
        <div class="navigation">
            <h2>Select a Business Case to View Details</h2>
            <ul class="problem-list">
                <li><a href="#case1">1. Smart Traffic Signal Optimization üö¶</a></li>
                <li><a href="#case2">2. Emergency Vehicle Route Prioritization üö®</a></li>
                <li><a href="#case3">3. Smart Public Parking Management üÖøÔ∏è</a></li>
                <li><a href="#case4">4. Integrated Public Transport System (IPTS) üöå</a></li>
                <li><a href="#case5">5. Water Resource Management & Flood Prediction üåä</a></li>
                <li><a href="#case6">6. Solid Waste Collection Route Optimization üóëÔ∏è</a></li>
                <li><a href="#case7">7. Smart Energy Grid Balancing ‚ö°</a></li>
                <li><a href="#case8">8. Air Quality Monitoring & Mitigation üå¨Ô∏è</a></li>
                <li><a href="#case9">9. Disaster Response and Evacuation Planning üÜò</a></li>
                <li><a href="#case10">10. Last-Mile Delivery Optimization üõµ</a></li>
            </ul>
        </div>

        <hr>

        <section id="case1" class="content-section">
            <h2 class="problem-title">1. Smart Traffic Signal Optimization üö¶</h2>
            
            <h3>Problem Statement</h3>
            <p>The current fixed-time traffic signals in the densely populated **Residential Area** and high-traffic junctions lead to unnecessary long waiting times on less-busy roads. This increases fuel consumption, commuter frustration, and overall congestion during non-peak hours.</p>

            <h3>Data Structures & C++ Code</h3>
            <p>We use a **Graph** (`std::map`) to model the road network and a **Min-Heap** (`std::priority_queue`) for efficient route planning using Dijkstra's/A* algorithm.</p>
            <pre><code>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;map&gt;

// Define a structure for a road segment (Edge)
struct RoadSegment {
    int destination_junction;
    int current_weight; 
    int base_weight;    
};

// Define the Junction/Node structure
using Junction = int; 
using TrafficGraph = std::map&lt;Junction, std::vector&lt;RoadSegment&gt;&gt;;

// Min-Heap (Priority Queue) element for Dijkstra's
using PQElement = std::pair&lt;int, Junction&gt;;
            </code></pre>

            <h3>Application Logic</h3>
            <ul>
                <li>**Adaptive Weight:** Edge weights are dynamically updated: $Current\ Weight = Base\ Weight + (\alpha \times Queue\ Length)$.</li>
                <li>**Signal Timing:** Green time is allocated based on "Traffic Pressure" (Queue Length $\times$ Base Weight) for incoming lanes.</li>
                <li>**Route Suggestions:** Dijkstra's algorithm runs on the live-weighted `TrafficGraph` to suggest the fastest route.</li>
            </ul>

            <h3>Analysis & Complexity</h3>
            <p>Core routing time complexity is $O(E \log V)$ for Dijkstra's algorithm. This is highly efficient for real-time traffic management.</p>
            <a href="#top" class="back-to-top">‚Üë Back to Navigation Menu</a>
        </section>

        <section id="case2" class="content-section">
            <h2 class="problem-title">2. Emergency Vehicle Route Prioritization üö®</h2>

            <h3>Problem Statement</h3>
            <p>Emergency response times (e.g., from the **Hospital** to an incident) are critically delayed by standard traffic light cycles. This system ensures immediate, guaranteed route clearance.</p>
            
            <h3>Data Structures & C++ Code</h3>
            <p>Extends `TrafficGraph` with structures for active routes and quick road segment clearance tracking using a **Deque** and an **Unordered Set**.</p>
            <pre><code>
#include &lt;deque&gt;
#include &lt;unordered_set&gt;

// Structure to track an active emergency vehicle route
struct EmergencyRoute {
    std::string vehicle_id;
    std::deque&lt;Junction&gt; path; // Sequence of junctions
};

// Data structure to store and manage active emergency routes
using ActiveRoutes = std::vector&lt;EmergencyRoute&gt;;

// Data structure to quickly check which roads are currently 'cleared'
using ClearedRoads = std::unordered_set&lt;std::pair&lt;Junction, Junction&gt;&gt;;
            </code></pre>

            <h3>Application Logic</h3>
            <ul>
                <li>**Path Calculation:** An immediate fastest path is calculated when dispatched.</li>
                <li>**Signal Override:** Signals along the route are immediately forced to **Green** for the emergency vehicle's direction, and cross-traffic is forced to **Red**.</li>
                <li>**Dynamic Update:** The "cleared" state propagates dynamically just ahead of the vehicle using the deque.</li>
            </ul>

            <h3>Analysis & Complexity</h3>
            <p>Path calculation is $O(E \log V)$. The critical signal override and clearance update is an **$O(1)$** operation per junction, ensuring low latency.</p>
            <a href="#top" class="back-to-top">‚Üë Back to Navigation Menu</a>
        </section>

        <section id="case3" class="content-section">
            <h2 class="problem-title">3. Smart Public Parking Management üÖøÔ∏è</h2>
            <h3>Problem Statement</h3>
            <p>Focuses on parking areas near the **Hospital**, **Market**, and **Hotel**. Problem: Drivers waste time searching for empty spots, causing localized traffic congestion.</p>
            <h3>Data Structures & C++ Code</h3>
            <p>A **Hash Map** (`std::unordered_map`) stores parking slot status (Occupied/Free) linked to a **Trie** or **Spatial Index** for efficient geo-location search.</p>
            <pre><code>
#include &lt;unordered_map&gt;
#include &lt;string&gt;

// Structure for a single parking slot
struct ParkingSlot {
    std::string lot_id;
    bool is_occupied;
    int last_updated_time;
};

// Map slot ID (string) to its status (ParkingSlot structure)
using SlotStatusMap = std::unordered_map&lt;std::string, ParkingSlot&gt;;

// Structure for a Trie Node (for searching parking by area name)
struct TrieNode {
    std::unordered_map&lt;char, TrieNode*&gt; children;
    std::vector&lt;std::string&gt; slot_IDs; // List of slots in this area
};
            </code></pre>
            <h3>Application Logic</h3>
            <p>Sensors detect occupancy. The system uses real-time data to guide drivers via an app or digital signs to the nearest available zone.</p>
            <h3>Analysis & Complexity</h3>
            <p>The system relies on fast lookups ($O(1)$ average) in the Hash Map to retrieve slot status and $O(L)$ for Trie search (where $L$ is area name length).</p>
            <a href="#top" class="back-to-top">‚Üë Back to Navigation Menu</a>
        </section>

        <section id="case4" class="content-section">
            <h2 class="problem-title">4. Integrated Public Transport System (IPTS) üöå</h2>
            <h3>Problem Statement</h3>
            <p>Inefficient connections and poor scheduling between the **Railway Station**, **Bus Stand**, and major **Residential Areas** discourage public transport usage.</p>
            <h3>Data Structures & C++ Code</h3>
            <p>A **Time-Expanded Graph** is used where nodes represent (stop, time) pairs. A **Priority Queue** manages vehicle movement and transfers.</p>
            <pre><code>
#include &lt;queue&gt;

// Represents a node in the Time-Expanded Graph: (Stop ID, Departure Time)
struct TEG_Node {
    int stop_id;
    int time_point;
};

// Edge represents a journey (bus ride or transfer)
struct TEG_Edge {
    TEG_Node destination;
    int travel_time;
};

// A Min-Heap for Dijkstra's on the TEG, prioritizing earlier arrival time
using TEG_PQ = std::priority_queue&lt;
    std::pair&lt;int, TEG_Node&gt;, 
    std::vector&lt;std::pair&lt;int, TEG_Node&gt;&gt;, 
    std::greater&lt;std::pair&lt;int, TEG_Node&gt;&gt;
&gt;;
            </code></pre>
            <h3>Application Logic</h3>
            <p>Dynamically adjusts bus schedules based on passenger load and traffic (from Case 1), ensuring timely connections at the main hubs like the Railway Station.</p>
            <h3>Analysis & Complexity</h3>
            <p>Route optimization runs Dijkstra's on the TEG, $O(V_{TE} \log V_{TE})$, where $V_{TE}$ is the number of (stop, time) nodes.</p>
            <a href="#top" class="back-to-top">‚Üë Back to Navigation Menu</a>
        </section>

        <section id="case5" class="content-section">
            <h2 class="problem-title">5. Water Resource Management & Flood Prediction üåä</h2>
            <h3>Problem Statement</h3>
            <p>Unpredictable river flow and Dam releases threaten the low-lying **Farm** areas and riverside **Residential Areas** with flooding.</p>
            <h3>Data Structures & C++ Code</h3>
            <p>A **Time Series Database** concept is used, implemented with a **Vector** of structured sensor readings. A **Queue** manages alert dissemination.</p>
            <pre><code>
#include &lt;vector&gt;
#include &lt;queue&gt;

// Structure to hold a time-series data point
struct WaterReading {
    long long timestamp;
    int water_level_cm; // Sensor data from Dam/River
    int flow_rate_m3s;
};

// Main Time Series Storage (Chronologically sorted vector)
using TimeSeriesData = std::vector&lt;WaterReading&gt;;

// Queue to hold high-priority flood alerts before sending
using AlertQueue = std::queue&lt;std::string&gt;;
            </code></pre>
            <h3>Application Logic</h3>
            <p>Uses predictive modeling (like statistical regression) on the time series data to forecast water levels and automatically trigger alerts via the `AlertQueue` if a threshold is crossed.</p>
            <h3>Analysis & Complexity</h3>
            <p>Data lookups use Binary Search on the sorted vector $O(\log N)$. Alert processing is fast ($O(1)$ dequeuing).</p>
            <a href="#top" class="back-to-top">‚Üë Back to Navigation Menu</a>
        </section>

        <section id="case6" class="content-section">
            <h2 class="problem-title">6. Solid Waste Collection Route Optimization üóëÔ∏è</h2>
            <h3>Problem Statement</h3>
            <p>Inefficient, fixed routes for waste collection lead to over-full bins in some areas and unnecessary trips to the **Dump/Landfill** location.</p>
            <h3>Data Structures & C++ Code</h3>
            <p>A **Graph** similar to traffic, but weights are based on **Fill Level** and **Time Since Last Collection**. The problem is a variation of the **Traveling Salesperson Problem (TSP)**.</p>
            <pre><code>
#include &lt;vector&gt;
#include &lt;map&gt;

// Structure representing a smart bin
struct SmartBin {
    int bin_id;
    double fill_level; // 0.0 to 1.0
    int location_x, location_y;
};

// Graph adjacency matrix for distance/cost between collection points
using DistanceMatrix = std::vector&lt;std::vector&lt;int&gt;&gt;;

// Map to efficiently select only 'ready' bins for the TSP algorithm
using ReadyBins = std::map&lt;int, SmartBin&gt;;
            </code></pre>
            <h3>Application Logic</h3>
            <p>An approximation algorithm (e.g., Christofides) solves the TSP variation daily, using the `DistanceMatrix` and only the `ReadyBins` to create the most efficient route.</p>
            <h3>Analysis & Complexity</h3>
            <p>Approximation algorithms for TSP are necessary since the problem is NP-hard. For $N$ bins, the complexity is typically $O(N^3)$ or worse for certain approximations.</p>
            <a href="#top" class="back-to-top">‚Üë Back to Navigation Menu</a>
        </section>

        <section id="case7" class="content-section">
            <h2 class="problem-title">7. Smart Energy Grid Balancing ‚ö°</h2>
            <h3>Problem Statement</h3>
            <p>Unpredictable high-load spikes from the **Factory** and **Industrial Area** can cause blackouts in the nearby **Residential Areas**.</p>
            <h3>Data Structures & C++ Code</h3>
            <p>A **Graph** models the electrical sub-station hierarchy and connections. A **Priority Queue** manages load shedding/re-routing requests based on urgency.</p>
            <pre><code>
#include &lt;queue&gt;
#include &lt;map&gt;

// Represents an electrical sub-station or connection point
struct Substation {
    int id;
    double current_load; // MW
    int priority_level;  // 1=High (Hospital), 3=Low (Non-critical)
};

// Graph of the power grid connections
using PowerGridGraph = std::map&lt;int, std::vector&lt;int&gt;&gt;;

// Min-Heap to prioritize load re-routing/shedding for lowest priority areas first
using LoadPriorityQueue = std::priority_queue&lt;
    Substation, 
    std::vector&lt;Substation&gt;, 
    std::greater&lt;Substation&gt;
&gt;;
            </code></pre>
            <h3>Application Logic</h3>
            <p>The system re-routes power or sheds load using the `LoadPriorityQueue`. It checks the `PowerGridGraph` for alternative paths using a fast traversal algorithm (like DFS/BFS) to prevent cascading failures.</p>
            <h3>Analysis & Complexity</h3>
            <p>Graph traversal (DFS/BFS) for re-routing is fast, $O(V+E)$, making decision-making instantaneous during power events.</p>
            <a href="#top" class="back-to-top">‚Üë Back to Navigation Menu</a>
        </section>

        <section id="case8" class="content-section">
            <h2 class="problem-title">8. Air Quality Monitoring & Mitigation üå¨Ô∏è</h2>
            <h3>Problem Statement</h3>
            <p>Emissions from the **Industrial Area** and **Factory** negatively impact air quality in downwind **Residential Areas** and recreational zones like the **Park/Stadium**.</p>
            <h3>Data Structures & C++ Code</h3>
            <p>A **2D Array** represents a spatial grid of the city for sensor readings. A **B-Tree** concept (simulated by sorted structures) is used for efficient query management.</p>
            <pre><code>
#include &lt;vector&gt;
#include &lt;tuple&gt;

// A spatial grid for the city, storing the Air Quality Index (AQI) value
// [Row][Column] -> AQI Value
using AirQualityGrid = std::vector&lt;std::vector&lt;int&gt;&gt;;

// Structure for a recorded event/alert
struct AirQualityEvent {
    long long timestamp;
    int grid_x, grid_y;
    int aqi_value;
};

// Vector of events, conceptually organized like a B-Tree for time-based lookups
using EventLog = std::vector&lt;AirQualityEvent&gt;;
            </code></pre>
            <h3>Application Logic</h3>
            <p>Correlates pollutant readings (`AirQualityGrid`) with wind data. If high pollutant levels are predicted to reach residential zones, the system issues alerts and recommends industrial operational adjustments.</p>
            <h3>Analysis & Complexity</h3>
            <p>Spatial lookups in the grid are $O(1)$. Time-based range queries on the `EventLog` require $O(\log N)$ using binary search techniques.</p>
            <a href="#top" class="back-to-top">‚Üë Back to Navigation Menu</a>
        </section>

        <section id="case9" class="content-section">
            <h2 class="problem-title">9. Disaster Response and Evacuation Planning üÜò</h2>
            <h3>Problem Statement</h3>
            <p>Lack of pre-planned, optimized, and dynamic evacuation routes for high-density areas (School, Hospital, Stadium) during emergencies (e.g., dam break or major fire).</p>
            <h3>Data Structures & C++ Code</h3>
            <p>A **Graph** of the city where edge weights are dynamically updated to mark **blocked/unsafe** roads. **Breadth-First Search (BFS)** is ideal for finding shortest path in terms of segments.</p>
            <pre><code>
#include &lt;queue&gt;
#include &lt;map&gt;

// Graph structure where weight '0' or 'infinity' indicates blocked/unsafe
using EvacGraph = std::map&lt;int, std::vector&lt;std::pair&lt;int, int&gt;&gt;&gt;; // Node -> (Neighbor, Weight)

// Queue for Breadth-First Search (BFS) to find the shortest number of segments
using BFSQueue = std::queue&lt;int&gt;;

// Vector to store the sequence of junctions for the final optimal path
using EvacPath = std::vector&lt;int&gt;;
            </code></pre>
            <h3>Application Logic</h3>
            <p>Upon a disaster, the system uses **BFS** (since it finds the shortest path in an unweighted/uniformly weighted graph, minimizing segment count) on the `EvacGraph` to find the safest path to designated zones.</p>
            <h3>Analysis & Complexity</h3>
            <p>BFS is $O(V+E)$, providing the fastest possible calculation of the minimum number of road segments to an evacuation point, which is crucial during a disaster.</p>
            <a href="#top" class="back-to-top">‚Üë Back to Navigation Menu</a>
        </section>

        <section id="case10" class="content-section">
            <h2 class="problem-title">10. Last-Mile Delivery Optimization üõµ</h2>
            <h3>Problem Statement</h3>
            <p>Delivery services (vehicles/drones) face severe delays navigating the dense, complex road network and pedestrian zones of the **Residential Areas** and **Market**.</p>
            <h3>Data Structures & C++ Code</h3>
            <p>A **Graph** (similar to traffic) with time weights. A **Priority Queue** manages order scheduling and vehicle assignment to minimize idle time.</p>
            <pre><code>
#include &lt;queue&gt;
#include &lt;tuple&gt;

// Structure for an incoming delivery order
struct DeliveryOrder {
    int order_id;
    int delivery_location_junction;
    int deadline_time;
};

// Graph of the delivery network (can be same as TrafficGraph but with adjusted weights)
// Use TrafficGraph from Case 1

// Min-Heap (Priority Queue) prioritizing orders with the closest deadline
// Stores: (Deadline Time, Order ID)
using OrderPriorityQueue = std::priority_queue&lt;
    std::pair&lt;int, int&gt;, 
    std::vector&lt;std::pair&lt;int, int&gt;&gt;, 
    std::greater&lt;std::pair&lt;int, int&gt;&gt;
&gt;;
            </code></pre>
            <h3>Application Logic</h3>
            <p>The system uses Dijkstra's ($O(E \log V)$) with the live traffic `TrafficGraph` to calculate the fastest route for the next order pulled from the `OrderPriorityQueue`.</p>
            <h3>Analysis & Complexity</h3>
            <p>The primary computation for each delivery agent is the repeated shortest path search, running in $O(E \log V)$ time for the fastest route calculation.</p>
            <a href="#top" class="back-to-top">‚Üë Back to Navigation Menu</a>
        </section>

    </div>
</body>
</html>
